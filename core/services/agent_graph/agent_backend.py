import json
import re
from IPython.display import Image, display
from typing import Annotated, Literal, Optional
from typing_extensions import TypedDict
from langchain_core.messages import ToolMessage
from langgraph.graph.message import add_messages
from pydantic import BaseModel


class Reflection(BaseModel):
    """Schema untuk hasil refleksi agen terhadap output tool sebelumnya.

    Attributes:
        is_sufficient (bool): Apakah hasil tool sudah cukup untuk menjawab pertanyaan
        critique (str): Kritik terhadap hasil tool
        next_action (str): Tindakan selanjutnya - "FINISH" atau "RETRY"
        suggested_tool (Optional[str]): Tool yang disarankan untuk retry (jika ada)
        reasoning (str): Alasan untuk keputusan yang diambil
    """
    is_sufficient: bool
    critique: str
    next_action: Literal["FINISH", "RETRY"]
    suggested_tool: Optional[str] = None
    reasoning: str


class State(TypedDict):
    """Represents the state structure containing a list of messages and reflection results.

    Attributes:
        messages (list): A list of messages, where each message can be processed
        by adding messages using the `add_messages` function.
        reflection (Optional[Reflection]): Hasil refleksi dari supervisor agent
        retry_count (int): Jumlah retry yang sudah dilakukan untuk mencegah infinite loop
        final_response (Optional[str]): Final response content generated by final_response_generator
        user_query (Optional[str]): Original user query extracted from messages
        tools_used (Optional[list]): List of tools that have been used in this conversation
        next_route (Optional[str]): Next routing decision for multi-tool workflow
        pending_tools (Optional[list]): List of tools that still need to be executed
        multi_tool_guidance (Optional[str]): Guidance text for multi-tool scenarios
        quality_check_result (Optional[str]): Result of final response quality check
    """
    messages: Annotated[list, add_messages]
    reflection: Optional[Reflection]
    retry_count: int
    final_response: Optional[str]
    user_query: Optional[str]
    tools_used: Optional[list]
    next_route: Optional[str]
    pending_tools: Optional[list]
    multi_tool_guidance: Optional[str]
    quality_check_result: Optional[str]


class BasicToolNode:
    """A node that runs the tools requested in the last AIMessage.

    This class retrieves tool calls from the most recent AIMessage in the input
    and invokes the corresponding tool to generate responses.

    Attributes:
        tools_by_name (dict): A dictionary mapping tool names to tool instances.
    """

    def __init__(self, tools: list) -> None:
        """Initializes the BasicToolNode with available tools.

        Args:
            tools (list): A list of tool objects, each having a `name` attribute.
        """
        self.tools_by_name = {tool.name: tool for tool in tools}

    def __call__(self, inputs: dict):
        """Executes the tools based on the tool calls in the last message.

        Args:
            inputs (dict): A dictionary containing the input state with messages.

        Returns:
            dict: A dictionary with a list of `ToolMessage` outputs.

        Raises:
            ValueError: If no messages are found in the input.
        """
        if messages := inputs.get("messages", []):
            message = messages[-1]
        else:
            raise ValueError("No message found in input")

        outputs = []
        for tool_call in message.tool_calls:
            tool_name = tool_call["name"]

            # Debug logging for tool usage
            try:
                from .debug_logger import debug_logger
                debug_logger.log_step(
                    node_name="tool_execution",
                    step_type="TOOL_CALL",
                    description=f"Executing tool: {tool_name}",
                    data={
                        "tool_name": tool_name,
                        "tool_args": tool_call["args"],
                        "tool_call_id": tool_call["id"]
                    }
                )
            except ImportError:
                pass  # Debug logger not available

            tool_result = self.tools_by_name[tool_name].invoke(
                tool_call["args"]
            )
            # Prepare content for ToolMessage
            # If tool_result is already a string (e.g., from create_visualization), use it directly.
            # Otherwise, assume it's a dict/list and dump to JSON string.
            if isinstance(tool_result, str):
                content_for_message = tool_result
            else:
                content_for_message = json.dumps(tool_result)

            outputs.append(
                ToolMessage(
                    content=content_for_message,
                    name=tool_call["name"],
                    tool_call_id=tool_call["id"],
                )
            )
        return {"messages": outputs}


def route_tools(
    state: State,
) -> Literal["tools", "__end__"]:
    """

    Determines whether to route to the ToolNode or end the flow.

    This function is used in the conditional_edge and checks the last message in the state for tool calls. If tool
    calls exist, it routes to the 'tools' node; otherwise, it routes to the end.

    Args:
        state (State): The input state containing a list of messages.

    Returns:
        Literal["tools", "__end__"]: Returns 'tools' if there are tool calls;
        '__end__' otherwise.

    Raises:
        ValueError: If no messages are found in the input state.
    """
    if isinstance(state, list):
        ai_message = state[-1]
    elif messages := state.get("messages", []):
        ai_message = messages[-1]
    else:
        raise ValueError(
            f"No messages found in input state to tool_edge: {state}")
    if hasattr(ai_message, "tool_calls") and len(ai_message.tool_calls) > 0:
        return "tools"
    return "__end__"


def plot_agent_schema(graph):
    """Plots the agent schema using a graph object, if possible.

    Tries to display a visual representation of the agent's graph schema
    using Mermaid format and IPython's display capabilities. If the required
    dependencies are missing, it catches the exception and prints a message
    instead.

    Args:
        graph: A graph object that has a `get_graph` method, returning a graph
        structure that supports Mermaid diagram generation.

    Returns:
        None
    """
    try:
        display(Image(graph.get_graph().draw_mermaid_png()))
    except Exception:
        # This requires some extra dependencies and is optional
        return print("Graph could not be displayed.")


def reflection_node(state: State) -> dict:
    """
    ULTRA STRICT Reflection Node - Memaksa penggunaan tool yang tepat
    Enhanced with better tool detection and retry logic.
    """
    from langchain_google_genai import ChatGoogleGenerativeAI
    from ...utils.load_config import TOOLS_CFG

    print("üîç Running ULTRA STRICT Reflection Node...")

    messages = state.get("messages", [])
    retry_count = state.get("retry_count", 0)

    if not messages:
        return {
            "reflection": Reflection(
                is_sufficient=False,
                critique="No messages to analyze",
                next_action="RETRY",
                reasoning="Tidak ada pesan untuk dianalisis",
                suggested_tool=None
            ),
            "retry_count": retry_count + 1
        }

    # Get last human message untuk mengetahui pertanyaan user
    last_human_message = None
    for msg in reversed(messages):
        if hasattr(msg, 'type') and msg.type == 'human':
            last_human_message = msg
            break

    if not last_human_message:
        return {
            "reflection": Reflection(
                is_sufficient=False,
                next_action="RETRY",
                critique="No user question found",
                reasoning="Tidak ditemukan pertanyaan user",
                suggested_tool=None
            ),
            "retry_count": retry_count + 1
        }

    user_question = last_human_message.content.lower()
    print(f"üéØ Analyzing user question: {user_question}")

    # Check if any tools were called
    ai_messages = [msg for msg in messages if hasattr(
        msg, 'type') and msg.type == 'ai']
    last_ai_message = ai_messages[-1] if ai_messages else None

    if not last_ai_message:
        return {
            "reflection": Reflection(
                is_sufficient=False,
                next_action="RETRY",
                critique="No AI response found",
                reasoning="Tidak ada respons AI ditemukan",
                suggested_tool=None),
            "retry_count": retry_count + 1
        }

    tool_calls = getattr(last_ai_message, 'tool_calls', [])

    def detect_required_tool(question):
        """
        Deteksi tool yang WAJIB digunakan berdasarkan kata kunci dengan prioritas.
        Returns: (tool_name, category)
        """
        q = question.lower()

        # PRIORITAS 1: SPREADSHEET ETL Operations
        spreadsheet_keywords = ['spreadsheet',
                                'excel', 'upload', 'etl', 'file']
        spreadsheet_actions = ['ambil data', 'ambil file',
                               'proses data', 'update data', 'get data dari spreadsheet']

        if any(kw in q for kw in spreadsheet_keywords) or any(action in q for action in spreadsheet_actions):
            return 'trigger_spreadsheet_etl_and_get_summary', 'SPREADSHEET'

        if 'data terbaru' in q and any(context in q for context in ['spreadsheet', 'file', 'ambil']):
            return 'trigger_spreadsheet_etl_and_get_summary', 'SPREADSHEET'

        # PRIORITAS 2: INTERNET SEARCH - Only for clear external research
        internet_keywords = ['tesla', 'juara', 'ucl', 'berita', 'cuaca', 'internet', 'informasi umum',
                             'carikan di internet', 'cari di internet', 'tahun berapa terbentuk', 'didirikan',
                             'kapan', 'siapa pendiri', 'founded', 'established']

        if any(kw in q for kw in internet_keywords) and not any(internal in q for internal in ['spreadsheet', 'data internal', 'ambil data', 'file']):
            # PRIORITAS 3: VISUALISASI dengan smart data detection
            return 'tools_web_search', 'INTERNET_SEARCH'
        viz_keywords = ['grafik', 'chart', 'visualisasi',
                        'pie', 'bar', 'diagram', 'buat grafik', 'pie chart']
        has_viz_request = any(kw in q for kw in viz_keywords)

        if has_viz_request:
            # Cek apakah butuh data dari database dulu
            needs_data = any(data_kw in q for data_kw in [
                             'berapa', 'jumlah', 'bandingkan', 'total', 'olt', 'pelanggan', 'kota'])
            if needs_data:
                return 'query_asset_database', 'VISUALISASI_WITH_DATA'
            else:
                return 'create_visualization', 'VISUALISASI'

        # PRIORITAS 4: SPECIFIC ID QUERIES - FAT ID, Cluster ID, etc.
        fat_id_pattern = r'\b[A-Z]{3,4}\d{3,4}\b'
        fat_keywords = ['fat id', 'fat-id', 'fatid', 'fdt', 'olt']

        if re.search(fat_id_pattern, q.upper()) or any(kw in q for kw in fat_keywords):
            return 'query_asset_database', 'FAT_ID_LOOKUP'

        # PRIORITAS 5: LOCATION queries with technical terms
        location_keywords = ['dimana', 'letak', 'posisi',
                             'lokasi', 'alamat', 'berada', 'terletak']
        tech_terms = ['fat', 'fdt', 'olt', 'ont', 'cluster', 'pole']
        if any(loc in q for loc in location_keywords) and any(tech in q for tech in tech_terms):
            return 'query_asset_database', 'LOCATION_LOOKUP'

        # PRIORITAS 6: DATA DATABASE queries
        db_keywords = ['berapa', 'total', 'jumlah', 'bandingkan', 'hitung', 'cari data', 'data',
                       'pelanggan', 'brand', 'kota', 'cluster', 'lokasi', 'aset']
        if any(kw in q for kw in db_keywords):
            return 'query_asset_database', 'DATA_DATABASE'

        # PRIORITAS 7: DOKUMENTASI TEKNIS - Pure definition queries
        doc_pure_keywords = ['apa itu fat', 'apa itu fdt', 'apa itu iconnet', 'apa itu icon plus',
                             'apa itu pln', 'perbedaan fat fdt', 'hubungan fat',
                             'cara instalasi', 'panduan', 'sop', 'dokumentasi', 'konfigurasi',
                             'jelaskan', 'definisi', 'pengertian']
        if any(kw in q for kw in doc_pure_keywords):
            return 'search_internal_documents', 'DOKUMENTASI_TEKNIS'

        # DEFAULT: untuk komponen teknis dengan kata kerja data
        tech_components = ['fat', 'fdt', 'olt', 'ont',
                           'cluster', 'pole', 'iconnet', 'icon plus']
        if any(comp in q for comp in tech_components):
            return 'query_asset_database', 'TECHNICAL_DEFAULT'

        return None, None

    # Detect required tool
    required_tool, tool_category = detect_required_tool(user_question)
    print(
        f"üéØ Required tool detected: {required_tool} (Category: {tool_category})")

    # Get tools used
    tools_used = [tc['name'] for tc in tool_calls] if tool_calls else []
    print(f"üõ†Ô∏è Tools used: {tools_used}")

    # Get tool outputs for analysis
    tool_outputs = []
    for msg in messages:
        if hasattr(msg, 'type') and msg.type == 'tool':
            tool_outputs.append({
                'name': getattr(msg, 'name', 'unknown'),
                'content': msg.content[:200] + '...' if len(msg.content) > 200 else msg.content
            })

    # Enhanced validation logic
    if not required_tool:
        # No specific tool required, check if we have any meaningful output
        if tool_outputs:
            return {
                "reflection": Reflection(
                    is_sufficient=True,
                    next_action="FINISH",
                    critique="Question answered with available tools",
                    reasoning="Pertanyaan terjawab dengan tool yang tersedia"
                ),
                "retry_count": retry_count
            }
        else:
            # Fallback to documentation search
            return {
                "reflection": Reflection(
                    is_sufficient=False,
                    next_action="RETRY",
                    critique="No specific tool detected, trying documentation search",
                    reasoning="Tidak ada tool spesifik terdeteksi, coba cari dokumentasi",
                    suggested_tool="search_internal_documents"
                ),
                "retry_count": retry_count + 1
            }

    # Check if required tool was used
    if required_tool not in tools_used:
        print(
            f"‚ùå REQUIRED TOOL NOT USED! Expected: {required_tool}, Used: {tools_used}")
        return {
            "reflection": Reflection(
                is_sufficient=False,
                next_action="RETRY",
                critique=f"Required tool {required_tool} not used for {tool_category}",
                reasoning=f"Tool yang diperlukan {required_tool} belum digunakan untuk kategori {tool_category}",
                suggested_tool=required_tool
            ),
            "retry_count": retry_count + 1
        }

    # Tool was used, check quality of output
    for tool_output in tool_outputs:
        if tool_output['name'] == required_tool:
            content = tool_output['content'].lower()

            # Check for empty or error responses
            error_indicators = ['error', 'failed',
                                'tidak ditemukan', 'no results', 'empty']
            if any(indicator in content for indicator in error_indicators):
                print(f"‚ùå Tool {required_tool} returned error or empty result")

                # Suggest alternative tool based on category
                alternative_tools = {
                    'FAT_ID_LOOKUP': 'search_internal_documents',
                    'LOCATION_LOOKUP': 'search_internal_documents',
                    'DATA_DATABASE': 'sql_agent',
                    'DOKUMENTASI_TEKNIS': 'tools_web_search'
                }

                alternative = alternative_tools.get(tool_category, 'sql_agent')

                return {
                    "reflection": Reflection(
                        is_sufficient=False,
                        next_action="RETRY",
                        critique=f"Tool {required_tool} returned insufficient results",
                        reasoning=f"Tool {required_tool} memberikan hasil yang tidak memadai, coba alternatif",
                        suggested_tool=alternative
                    ),
                    "retry_count": retry_count + 1
                }

    # If we reach here, the required tool was used and returned meaningful results
    print(f"‚úÖ Required tool {required_tool} used successfully!")
    return {
        "reflection": Reflection(
            is_sufficient=True,
            next_action="FINISH",
            critique=f"Successfully used {required_tool} for {tool_category}",
            reasoning=f"Berhasil menggunakan {required_tool} untuk menjawab pertanyaan kategori {tool_category}"
        ),        "retry_count": retry_count
    }


def should_retry_or_finish(state: State) -> Literal["chatbot", "__end__"]:
    """
    Enhanced decision making for retry or finish based on reflection results.
    Considers retry count and reflection quality.
    """
    reflection = state.get("reflection")
    retry_count = state.get("retry_count", 0)

    # Safety check - prevent infinite loops
    MAX_RETRIES = 3
    if retry_count >= MAX_RETRIES:
        print(
            f"üõë Maximum retry limit ({MAX_RETRIES}) reached. Ending conversation.")
        return "__end__"

    # If no reflection available, end the conversation
    if not reflection:
        print("ÔøΩ No reflection available, ending conversation.")
        return "__end__"

    # Reflection says to retry with a specific tool
    if reflection.next_action == "RETRY" and reflection.suggested_tool:
        print(
            f"ÔøΩ Reflection suggests retry with tool: {reflection.suggested_tool}")
        return "chatbot"

    # Reflection says to finish (create final response)
    if reflection.next_action == "FINISH" and reflection.is_sufficient:
        print("‚úÖ Reflection indicates completion, generating final response.")
        return "chatbot"

    # Default: if reflection indicates insufficient response without specific tool, end
    if not reflection.is_sufficient and not reflection.suggested_tool:
        print(
            "‚ùå Reflection indicates insufficient response with no suggested tool. Ending.")
        return "__end__"    # Fallback to retry
    print("üîÑ Fallback: retry with chatbot")
    return "chatbot"


def should_retry_or_finish_legacy(state: State) -> Literal["chatbot", "__end__"]:
    """
    Conditional edge function yang menentukan apakah harus retry atau finish.
    Includes intelligent retry logic and max retry protection.

    Args:
        state (State): State saat ini

    Returns:
        str: "chatbot" untuk retry, "__end__" untuk finish
    """
    reflection = state.get("reflection")
    retry_count = state.get("retry_count", 0)

    # Batasi maksimal retry untuk mencegah infinite loop
    MAX_RETRIES = 2

    print(
        f"ü§î Should retry or finish? Current retry count: {retry_count}/{MAX_RETRIES}")

    if not reflection:
        print("üèÅ No reflection found, finishing...")
        return "__end__"

    if retry_count >= MAX_RETRIES:
        print(f"üîÑ Max retries ({MAX_RETRIES}) reached, finishing...")
        return "__end__"

    if reflection.next_action == "RETRY" and not reflection.is_sufficient:
        print(f"üîÑ Retrying... (attempt {retry_count + 1}/{MAX_RETRIES})")
        print(f"   Reason: {reflection.critique}")
        if reflection.suggested_tool:
            print(f"   Suggested tool: {reflection.suggested_tool}")
        return "chatbot"
    elif reflection.next_action == "FINISH" and reflection.is_sufficient:
        print("üîÑ Creating final response from tool results...")
        return "chatbot"  # Create final response instead of ending
    else:
        print("üèÅ Reflection indicates completion, finishing...")
        if reflection.is_sufficient:
            print("   ‚úÖ Task completed successfully")
        else:
            print("   ‚ö†Ô∏è Task incomplete but max retries reached")
        return "__end__"
